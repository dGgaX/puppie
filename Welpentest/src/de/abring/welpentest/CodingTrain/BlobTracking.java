/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.abring.welpentest.CodingTrain;

import com.github.sarxos.webcam.WebcamPanel;
import de.abring.welpentest.farbbegrenzer.FarbbegrenzerPanel;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Point;
import de.abring.welpentest.farbbegrenzer.Rectangle;
import java.awt.Color;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import javax.imageio.ImageIO;

/**
 *
 * @author Andreas
 */
public class BlobTracking implements WebcamPanel.Painter, MouseListener {

    private static final Image NO_IMAGE = getImage("image-missing-icon.png");
    
    private final FarbbegrenzerPanel farbbegrenzerPanel;
    
    private final int distThreshold = 50;
    
    private final List<Blob> blobs = new ArrayList<>();
    private final List<Point> gridPoints = new ArrayList<>();
    
    private final GridSquare[] gridSquares = new GridSquare[49];
    
    private boolean bw = false;
    private boolean pc = true;
    private boolean pr = false;
    
    private GridSquare activeGridSquare;
    private GridSquare lastGridSquare;
    
    private int blobCount = 0;
    private int px = 0;
    private int py = 0;
    
    /**
     *
     * @param farbbegrenzerPanel
     */
    public BlobTracking (FarbbegrenzerPanel farbbegrenzerPanel) {
        this.farbbegrenzerPanel = farbbegrenzerPanel;
        for (int i = 0; i < gridSquares.length; i++) {
            gridSquares[i] = new GridSquare();
        }
        activeGridSquare = gridSquares[25];
        lastGridSquare = gridSquares[25];
    }
    
    @Override
    public void paintPanel(WebcamPanel wp, Graphics2D g2) {
    
        int w1 = wp.getSize().width;
        int h1 = wp.getSize().height;
        int w2 = NO_IMAGE.getWidth(null);
        int h2 = NO_IMAGE.getHeight(null);

        g2.setColor(wp.getBackground());
        g2.fillRect(0, 0, w1, h1);
        g2.drawImage(NO_IMAGE, (w1 - w2) / 2, (h1 - h2) / 2, null);}

    @Override
    public void paintImage(WebcamPanel wp, BufferedImage image, Graphics2D g2) {
        List<Blob> currentBlobs = new ArrayList<>();
        
        for (int y = 0; y < image.getHeight(); y++) {
            for (int x = 0; x < image.getWidth(); x++) {
                if (farbbegrenzerPanel.isInRange(image.getRGB(x, y))) {
                    if (bw)
                        image.setRGB(x, y, Color.WHITE.getRGB());
                    
                    Point cp = new Point(x, y);
                    boolean found = false;
                    for (Blob b : currentBlobs) {
                        if (b.nearBy(cp, distThreshold)) {
                            b.add(x, y);
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        Blob b = new Blob(0, cp);
                        currentBlobs.add(b);
                    }
                    
                    
                    
                } else {
                    if (bw)
                        image.setRGB(x, y, Color.BLACK.getRGB());
                }
            }
        }
        
        for (int i = currentBlobs.size() - 1; i >= 0; i--) {
            if (currentBlobs.get(i).size() < 500) {
                currentBlobs.remove(i);
            }
        }

// There are no blobs!
        if (blobs.isEmpty() && currentBlobs.size() > 0) {
            System.out.println("Adding blobs!");
            currentBlobs.stream().map((b) -> {
                b.setId(blobCount);
                blobCount++;
                return b;
            }).forEachOrdered((b) -> {
                blobs.add(b);
            });
// Match whatever blobs you can match
        } else if (blobs.size() <= currentBlobs.size()) {
            blobs.forEach((Blob b) -> {
                double recordD = 1000;
                Blob matched = null;
                for (Blob cb : currentBlobs) {
                    Point centerB = b.center();
                    Point centerCB = cb.center();
                    
                    double d = distance(centerB, centerCB);
                    if (d < recordD && !cb.isTaken()) {
                        recordD = d;
                        matched = cb;
                    }
                }
                if (matched != null) {
                    matched.setTaken(true);
                    b.assimLocation(matched);
                }
            });

            // Whatever is leftover make new blobs
            currentBlobs.stream().filter((b) -> (!b.isTaken())).map((b) -> {
                b.setId(blobCount);
                blobCount++;
                return b;
            }).forEachOrdered((b) -> {
                blobs.add(b);
            });
// Match whatever blobs you can match
        } else if (blobs.size() > currentBlobs.size()) {
            blobs.forEach((b) -> {
                b.setTaken(false);
            });


            currentBlobs.forEach((cb) -> {
                double recordD = 1000;
                Point centerCB = cb.center();         
                Blob matched = null;
                
                for (Blob b : blobs) {
                    Point centerB = b.center();
                    double d = distance(centerB, centerCB);
                    if (d < recordD && !b.isTaken()) {
                        recordD = d; 
                        matched = b;
                    }
                }
                if (matched != null) {
                    matched.setTaken(true);
                    matched.resetLifespan();
                    matched.assimLocation(cb);
                }
            });

            for (int i = blobs.size() - 1; i >= 0; i--) {
                Blob b = blobs.get(i);
                if (!b.isTaken()) {
                    if (b.checkLifespan()) {
                        blobs.remove(i);
                    }
                }
            }
        }
        
        int w1 = wp.getSize().width;
        int h1 = wp.getSize().height;
        int w2 = image.getWidth();
        int h2 = image.getHeight();
        
        px = (w1 - w2) / 2;
        py = (h1 - h2) / 2;
        
        g2.drawImage(image, px, py, null);
        
        if (blobs.isEmpty()) {
            return;
        }
        
        if (gridPoints.size() == 4) {
            wp.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
            g2.setColor(Color.yellow);
            g2.drawLine(gridPoints.get(0).x + px, gridPoints.get(0).y + py, gridPoints.get(1).x + px, gridPoints.get(1).y + py);
            g2.drawLine(gridPoints.get(1).x + px, gridPoints.get(1).y + py, gridPoints.get(2).x + px, gridPoints.get(2).y + py);
            g2.drawLine(gridPoints.get(2).x + px, gridPoints.get(2).y + py, gridPoints.get(3).x + px, gridPoints.get(3).y + py);
            g2.drawLine(gridPoints.get(3).x + px, gridPoints.get(3).y + py, gridPoints.get(0).x + px, gridPoints.get(0).y + py);
        }
        
        
        for (GridSquare gs : gridSquares) {
            if (gs.contains(blobs.get(0).center())) {
                if (gs != this.activeGridSquare) {
                    if (gs != this.lastGridSquare) {
                        
                        
                        
                        
                        
                        
                        // Juchuu, es hat sich bewegt!
                        System.out.println("Es bewegt sich!");
                        
                        
                        
                        
                        
                    }
                    
                    this.lastGridSquare = this.activeGridSquare;
                    this.activeGridSquare = gs;
                }
                break;
            }
        }
        
        for (GridSquare gs : gridSquares) {
            gs.translate(px, py);
            if (gs == this.activeGridSquare)
                gs.paint(g2, GridSquare.IS_ACTIVE);
            else if (gs == this.lastGridSquare)
                gs.paint(g2, GridSquare.IS_PREVIO);
            else
                gs.paint(g2, GridSquare.IS_NORMAL);
            gs.translate(-px, -py);
        }
        
        blobs.forEach((b) -> {
            b.translate(px, py);
            if (pc)
                b.paintCross(g2);
            if (pr)
                b.paintRectangle(g2);
            b.translate(-px, -py);
        }); 
    }
    
    private double distance(Point a, Point b) {
        return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
    }
    
    private static Image getImage(String image) {
        try {
            return ImageIO.read(BlobTracking.class.getResource("/de/abring/welpentest/" + image));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private int RGBtoGray(int rgb) {
        int r = (rgb >> 16) & 0xFF;
        int g = (rgb >> 8) & 0xFF;
        int b = (rgb & 0xFF);
        int grayLevel = (r + g + b) / 3;
        return (grayLevel << 16) + (grayLevel << 8) + grayLevel; 
    }
    
    private boolean isPointInRectangles (Point p, List<Rectangle> r) {
        return r.stream().anyMatch((area) -> (area.contains(p)));
    }

    /**
     * @return the bw
     */
    public boolean isBw() {
        return bw;
    }

    /**
     * @param bw the bw to set
     */
    public void setBw(boolean bw) {
        this.bw = bw;
    }

    /**
     * @return the pc
     */
    public boolean isPc() {
        return pc;
    }

    /**
     * @param pc the pc to set
     */
    public void setPc(boolean pc) {
        this.pc = pc;
    }

    /**
     * @return the pr
     */
    public boolean isPr() {
        return pr;
    }

    /**
     * @param pr the pr to set
     */
    public void setPr(boolean pr) {
        this.pr = pr;
    }

    public void resetGrid() {
        gridPoints.clear();
    }
    
    private void letDownTheGrid() {
        
        for (int i = 0; i < 7; i++) {
            for (int j = 0; j < 7; j++) {
                
                /**
                 * 
                 * 
                 * 
                 * 
                 * 
                 * 
                 * Keine Ahnung,
                 * Was ich jetzt hier tun soll!!!
                 * 
                 * 
                 * 
                 * 
                 * 
                 * 
                 * 
                 */
                int c = i * 7 + j;
                
                int p1x = gridPoints.get(0).x + Math.round((gridPoints.get(1).x - gridPoints.get(0).x) * (i / 7.0f));
                int p1y = gridPoints.get(0).y + Math.round((gridPoints.get(3).y - gridPoints.get(0).y) * (j / 7.0f));
                int p2x = gridPoints.get(0).x + Math.round((gridPoints.get(1).x - gridPoints.get(0).x) * ((i + 1) / 7.0f));
                int p2y = gridPoints.get(0).y + Math.round((gridPoints.get(3).y - gridPoints.get(0).y) * (j / 7.0f));
                int p3x = gridPoints.get(0).x + Math.round((gridPoints.get(1).x - gridPoints.get(2).x) * (i / 7.0f));
                int p3y = gridPoints.get(0).y + Math.round((gridPoints.get(3).y - gridPoints.get(2).y) * ((j + 1) / 7.0f));
                int p4x = gridPoints.get(0).x + Math.round((gridPoints.get(1).x - gridPoints.get(2).x) * ((i + 1) / 7.0f));
                int p4y = gridPoints.get(0).y + Math.round((gridPoints.get(3).y - gridPoints.get(2).y) * ((j + 1) / 7.0f));
                
                gridSquares[c] = new GridSquare(new Point(p1x, p1y), new Point(p2x, p2y), new Point(p3x, p3y), new Point(p4x, p4y));
                
            }
        }
    }
    
    @Override
    public void mouseClicked(MouseEvent me) {
        if (gridPoints.size() >= 4)
            return;
        int x = me.getX() - px;
        int y = me.getY() - py;
        gridPoints.add(new Point(x, y));
        if (gridPoints.size() == 4)
            letDownTheGrid();
    }

    @Override
    public void mousePressed(MouseEvent me) {
    }

    @Override
    public void mouseReleased(MouseEvent me) {
    }

    @Override
    public void mouseEntered(MouseEvent me) {
    }

    @Override
    public void mouseExited(MouseEvent me) {
    }
}
