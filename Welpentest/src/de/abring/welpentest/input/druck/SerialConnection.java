/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.abring.welpentest.input.druck;

import gnu.io.CommPort;
import gnu.io.CommPortIdentifier;
import gnu.io.PortInUseException;
import gnu.io.SerialPort;
import gnu.io.SerialPortEvent;
import gnu.io.SerialPortEventListener;
import java.awt.Event;
import java.awt.Point;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Wohnzimmer
 */
public class SerialConnection {
    
    private long startMillis = System.currentTimeMillis();
        
    private String lastCommand = "";
    
    private CommPortIdentifier selectedPort = null;
    private SerialPort selectedSerialPort;
    private OutputStream output = null;
    private InputStream input = null;
    private HashSet<CommPortIdentifier> h = getAvailableSerialPorts();
    private boolean connected = false;
    
    
    public SerialConnection() {
    }
    
    public void writeToCommPort(String command) {
        if (isConnected() && output != null && !command.equals(lastCommand)) {
            try {
                System.out.println("> " + command);
                output.write(command.getBytes());
//                lastCommand = command;
            } catch (IOException ex) {
                Logger.getLogger(SerialConnection.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    
    public HashSet<CommPortIdentifier> getAvailableCommPorts() {
        return h;
    }
    
    public void selectCommPort(int i) {
        selectedPort = (CommPortIdentifier)h.toArray()[i];
        System.out.println("> " + selectedPort.getName());
    }
    
    public boolean commPortSelected() {
        return (selectedPort != null);
    }
    
    public boolean isConnected() {
        return connected;
    }
    
    public void connect() {
        if ( selectedPort.isCurrentlyOwned() )
        {
            System.out.println("Error: Port is currently in use");
        }
        else
        {
            try {
                CommPort commPort = selectedPort.open(this.getClass().getName(),2000);

                if ( commPort instanceof SerialPort )
                {
                    selectedSerialPort = (SerialPort) commPort;
                    selectedSerialPort.setSerialPortParams(9600,SerialPort.DATABITS_8,SerialPort.STOPBITS_1,SerialPort.PARITY_NONE);
                    
                    input = selectedSerialPort.getInputStream();
                    output = selectedSerialPort.getOutputStream();
                    
                    connected = true;
 
                    selectedSerialPort.addEventListener((SerialPortEvent spe) -> {
                        int data;
                        byte[] buffer = new byte[1024];
                        int len = 0;
                        try {
                            while ( ( data = input.read()) > -1 )
                            {
                                if ( data == '\n' || data == '\r' ) {
                                    break;
                                }
                                buffer[len++] = (byte) data;
                            }
                        } catch (IOException ex) {
                            Logger.getLogger(SerialConnection.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        String inpString = new String(buffer,0,len);
                        System.out.println("< " + inpString);
                        
                        executeTransmission(inpString);
                        
                        
//                        float floatV = Float.parseFloat(inpString) * 100;
//                        int tickMillis = Math.toIntExact(System.currentTimeMillis() - startMillis);
//                        Point tick = new Point(tickMillis, Math.round(floatV * 100));
//                        executeTransmission(tick);

                    });
                    selectedSerialPort.notifyOnDataAvailable(true);
                }
                else
                {
                    System.out.println("Error: Only serial ports are handled by this example.");
                }
            } catch (Exception ex) {
                Logger.getLogger(SerialConnection.class.getName()).log(Level.SEVERE, null, ex);
            }
        }     
    }
    
    public void disconnect() {
        if (selectedSerialPort != null) {
            try {
                output.close();
                output = null;
                connected = false;
            } catch (IOException ex) {
                Logger.getLogger(SerialConnection.class.getName()).log(Level.SEVERE, null, ex);
            }
            selectedSerialPort.close();
        }
    }
    
    private static HashSet<CommPortIdentifier> getAvailableSerialPorts() {
        HashSet<CommPortIdentifier> h = new HashSet<CommPortIdentifier>();
        Enumeration thePorts = CommPortIdentifier.getPortIdentifiers();
        while (thePorts.hasMoreElements()) {
            CommPortIdentifier com = (CommPortIdentifier) thePorts.nextElement();
            switch (com.getPortType()) {
            case CommPortIdentifier.PORT_SERIAL:
                try {
                    CommPort thePort = com.open("CommUtil", 50);
                    thePort.close();
                    h.add(com);
                } catch (PortInUseException e) {
                    System.out.println("Port, "  + com.getName() + ", is in use.");
                } catch (Exception e) {
                    System.err.println("Failed to open port " +  com.getName());
                    e.printStackTrace();
                }
            }
        }
        return h;
    }
    
    private final List<DruckListener> listeners = new ArrayList<>();

    public void addListener(DruckListener toAdd) {
        listeners.add(toAdd);
    }
    
    public void removeListener(DruckListener toRemove) {
        listeners.remove(toRemove);
    }
    
    public void executeTransmission(Point p) {
        DruckEvent evt = new DruckEvent(p);
        listeners.forEach((hl) -> {
            hl.audioDetected(evt);
        });
    }

    public void executeTransmission(String s) {
        DruckEvent evt = new DruckEvent(s);
        listeners.forEach((hl) -> {
            hl.audioDetected(evt);
        });
    }
}
