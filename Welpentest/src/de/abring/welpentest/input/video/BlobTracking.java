/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.abring.welpentest.input.video;

import com.github.sarxos.webcam.WebcamPanel;
import de.abring.welpentest.gui.components.colorRange.ColorRangePanel;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Point;
import java.awt.Color;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;
import java.io.IOException;
import static java.lang.Thread.sleep;
import java.util.ArrayList;
import java.util.List;
import javax.imageio.ImageIO;

/**
 *
 * @author Andreas
 */
public class BlobTracking implements WebcamPanel.Painter, MouseListener {

    private static final Image NO_IMAGE = getImage("image-missing-icon.png");
    
    private final ColorRangePanel colorRangePanel;
    
    private final int distThreshold = 50;
    
    private final List<Blob> blobs = new ArrayList<>();
    private final List<Point> gridPoints = new ArrayList<>();

    private final List<MovementListener> listeners = new ArrayList<>();

    private final GridSquare[] gridSquares = new GridSquare[49];
    
    private Blob trackingBlob = new Blob(-1, new Point (0, 0));
    
    private boolean bw = false;
    private boolean pc = true;
    private boolean pr = false;
    
    private GridSquare activeGridSquare;
    private GridSquare lastGridSquare;
    
    
    private int blobCount = 0;
    
    private int px = 0;
    private int py = 0;
    
    /**
     *
     * @param farbbegrenzerPanel
     */
    public BlobTracking (ColorRangePanel colorRangePanel) {
        this.colorRangePanel = colorRangePanel;
        for (int i = 0; i < gridSquares.length; i++) {
            gridSquares[i] = new GridSquare();
        }
        activeGridSquare = gridSquares[25];
        lastGridSquare = gridSquares[25];
        borderCrossThread.start();
        movementThread.start();
        movementStempThread.start();
    }
    
    private final Thread borderCrossThread = new Thread() {
        private long startMillis = System.currentTimeMillis();
        private int crossBorderCount = 0;
        @Override
        public void run() {
            while(true) {
                try {
                    sleep(200);
                    for (GridSquare gs : gridSquares) {
                        if (gs.contains(trackingBlob.center())) {
                            if (gs != activeGridSquare) {
                                if (gs != lastGridSquare) {
                                    System.out.println("Es bewegt sich!");
                                    crossBorderCount++;
                                    int tickMillis = Math.toIntExact(System.currentTimeMillis() - startMillis);
                                    Point tick = new Point(tickMillis, crossBorderCount);
                                    executeBorderCross(tick);
                                }
                                lastGridSquare = activeGridSquare;
                                activeGridSquare = gs;
                            }
                            break;
                        }
                    }
                } catch(InterruptedException e) {
                    startMillis = System.currentTimeMillis();
                    crossBorderCount = 0;
                }
            }
        }
    };
    
    private final Thread movementThread = new Thread() {
        private long startMillis = System.currentTimeMillis();
        private Point previoP = trackingBlob.center();
        int movement = 0;
        @Override
        public void run() {
            while(true) {
                try {
                    sleep(100);
                    Point actualP = trackingBlob.center();
                    
                    movement += distance(actualP, previoP);
                    
                    int tickMillis = Math.toIntExact(System.currentTimeMillis() - startMillis);
                    
                    Point tick = new Point(tickMillis, movement);
                        
                    executeMovement(tick);
                    
                    previoP = actualP;
                    
                } catch(InterruptedException e) {
                    startMillis = System.currentTimeMillis();
                    movement = 0;
                }
            }
        }
    };
    
    private final Thread movementStempThread = new Thread() {
        private long startMillis = System.currentTimeMillis();
        private Point previoP = trackingBlob.center();
        private boolean previoB = false;
        @Override
        public void run() {
            while(true) {
                try {
                    sleep(500);
                    Point actualP = trackingBlob.center();
                    boolean actualB = distance(actualP, previoP) > 30.0d;
                    if (actualB != previoB) {
                        int tickMillis = Math.toIntExact(System.currentTimeMillis() - startMillis);
                        Point tick;
                        if (actualB)
                            tick = new Point(tickMillis, 2);
                        else 
                            tick = new Point(tickMillis, 1);
                        executeMovementStemp(tick);
                    }
                    previoP = actualP;
                    previoB = actualB;
                    
                } catch(InterruptedException e) {
                    startMillis = System.currentTimeMillis();
                }
            }
        }
    };
    
    public void resetThreads() {
        borderCrossThread.interrupt();
        movementThread.interrupt();
        movementStempThread.interrupt();
    }
    
    @Override
    public void paintPanel(WebcamPanel wp, Graphics2D g2) {
    
        int w1 = wp.getSize().width;
        int h1 = wp.getSize().height;
        int w2 = NO_IMAGE.getWidth(null);
        int h2 = NO_IMAGE.getHeight(null);

        g2.setColor(wp.getBackground());
        g2.fillRect(0, 0, w1, h1);
        g2.drawImage(NO_IMAGE, (w1 - w2) / 2, (h1 - h2) / 2, null);}

    @Override
    public void paintImage(WebcamPanel wp, BufferedImage image, Graphics2D g2) {
        List<Blob> currentBlobs = new ArrayList<>();
        
        for (int y = 0; y < image.getHeight(); y++) {
            for (int x = 0; x < image.getWidth(); x++) {
                if (colorRangePanel.isInRange(image.getRGB(x, y))) {
                    if (bw)
                        image.setRGB(x, y, Color.WHITE.getRGB());
                    
                    Point cp = new Point(x, y);
                    boolean found = false;
                    for (Blob b : currentBlobs) {
                        if (b.nearBy(cp, distThreshold)) {
                            b.add(x, y);
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        Blob b = new Blob(0, cp);
                        currentBlobs.add(b);
                    }
                    
                    
                    
                } else {
                    if (bw)
                        image.setRGB(x, y, Color.BLACK.getRGB());
                }
            }
        }
        
        for (int i = currentBlobs.size() - 1; i >= 0; i--) {
            if (currentBlobs.get(i).size() < 500) {
                currentBlobs.remove(i);
            }
        }

// There are no blobs!
        if (blobs.isEmpty() && currentBlobs.size() > 0) {
            System.out.println("Adding blobs!");
            currentBlobs.stream().map((b) -> {
                b.setId(blobCount);
                blobCount++;
                return b;
            }).forEachOrdered((b) -> {
                blobs.add(b);
            });
// Match whatever blobs you can match
        } else if (blobs.size() <= currentBlobs.size()) {
            blobs.forEach((Blob b) -> {
                double recordD = 1000;
                Blob matched = null;
                for (Blob cb : currentBlobs) {
                    Point centerB = b.center();
                    Point centerCB = cb.center();
                    
                    double d = distance(centerB, centerCB);
                    if (d < recordD && !cb.isTaken()) {
                        recordD = d;
                        matched = cb;
                    }
                }
                if (matched != null) {
                    matched.setTaken(true);
                    b.assimLocation(matched);
                }
            });

            // Whatever is leftover make new blobs
            currentBlobs.stream().filter((b) -> (!b.isTaken())).map((b) -> {
                b.setId(blobCount);
                blobCount++;
                return b;
            }).forEachOrdered((b) -> {
                blobs.add(b);
            });
// Match whatever blobs you can match
        } else if (blobs.size() > currentBlobs.size()) {
            blobs.forEach((b) -> {
                b.setTaken(false);
            });


            currentBlobs.forEach((cb) -> {
                double recordD = 1000;
                Point centerCB = cb.center();         
                Blob matched = null;
                
                for (Blob b : blobs) {
                    Point centerB = b.center();
                    double d = distance(centerB, centerCB);
                    if (d < recordD && !b.isTaken()) {
                        recordD = d; 
                        matched = b;
                    }
                }
                if (matched != null) {
                    matched.setTaken(true);
                    matched.resetLifespan();
                    matched.assimLocation(cb);
                }
            });

            for (int i = blobs.size() - 1; i >= 0; i--) {
                Blob b = blobs.get(i);
                if (!b.isTaken()) {
                    if (b.checkLifespan()) {
                        blobs.remove(i);
                    }
                }
            }
        }
        
        int w1 = wp.getSize().width;
        int h1 = wp.getSize().height;
        int w2 = image.getWidth();
        int h2 = image.getHeight();
        
        px = (w1 - w2) / 2;
        py = (h1 - h2) / 2;
        
        g2.drawImage(image, px, py, null);
        
        if (blobs.isEmpty()) {
            return;
        }
        
        g2.setColor(Color.yellow);
        if (gridPoints.size() < 4) {
            gridPoints.forEach((p) -> {
                p.translate(px, py);
                g2.fillOval(p.x - 5, p.y - 5, 11, 11);
                p.translate(-px, -py);
            });
        }
        
        for (GridSquare gs : gridSquares) {
            gs.translate(px, py);
            if (gs != this.activeGridSquare || gs != this.lastGridSquare)
                gs.paint(g2, GridSquare.IS_NORMAL);
            gs.translate(-px, -py);
        }
            
        this.lastGridSquare.translate(px, py);
        this.lastGridSquare.paint(g2, GridSquare.IS_PREVIO);
        this.lastGridSquare.translate(-px, -py);
        
        this.activeGridSquare.translate(px, py);
        this.activeGridSquare.paint(g2, GridSquare.IS_ACTIVE);
        this.activeGridSquare.translate(-px, -py);
            
        
        blobs.forEach((b) -> {
            b.translate(px, py);
            if (pc)
                b.paintCross(g2);
            if (pr)
                b.paintRectangle(g2);
            b.translate(-px, -py);
        }); 
    }
    
    private double distance(Point a, Point b) {
        return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
    }
    
    private static Image getImage(String image) {
        try {
            return ImageIO.read(BlobTracking.class.getResource("/de/abring/welpentest/video/" + image));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private int RGBtoGray(int rgb) {
        int r = (rgb >> 16) & 0xFF;
        int g = (rgb >> 8) & 0xFF;
        int b = (rgb & 0xFF);
        int grayLevel = (r + g + b) / 3;
        return (grayLevel << 16) + (grayLevel << 8) + grayLevel; 
    }
        
    /**
     * @return the bw
     */
    public boolean isBw() {
        return bw;
    }

    /**
     * @param bw the bw to set
     */
    public void setBw(boolean bw) {
        this.bw = bw;
    }

    /**
     * Lets have a look weahter the Cross is painted an the Screen
     * @return the pc PrintCross boolean value
     */
    public boolean isPc() {
        return pc;
    }

    /**
     * Lets you decide to Paint or not to Paint the Cross
     * @param pc the pc to set
     */
    public void setPc(boolean pc) {
        this.pc = pc;
    }

    /**
     * Lets have a look weahter the Rectangle is painted an the Screen
     * @return the pr
     */
    public boolean isPr() {
        return pr;
    }

    /**
     * Lets you decide to Paint or not to Paint the Cross
     * @param pr the pr to set
     */
    public void setPr(boolean pr) {
        this.pr = pr;
    }

    /**
     * resets the Grid so you can create a new one
     */
    public void resetGrid() {
        gridPoints.clear();
    }
    
    /**
     * Takes all four Gridpoints
     * and divides them into 49 (7x7)
     * squares with whom we can detect
     * weather the puppie crosses the borders
     */
    private void letDownTheGrid() {
        for (int j = 0; j < 7; j++) {
            for (int i = 0; i < 7; i++) {
                int c = j * 7 + i;
                
                float px0    = gridPoints.get(0).x;
                float py0    = gridPoints.get(0).y;
                float px1    = gridPoints.get(1).x + 1;
                float py1    = gridPoints.get(1).y;
                float px2    = gridPoints.get(2).x + 1;
                float py2    = gridPoints.get(2).y + 1;
                float px3    = gridPoints.get(3).x;
                float py3    = gridPoints.get(3).y + 1;
                float px0px1 = gridPoints.get(1).x - gridPoints.get(0).x;
                float py0py1 = gridPoints.get(1).y - gridPoints.get(0).y;
                float px1px2 = gridPoints.get(2).x - gridPoints.get(1).x;
                float py1py2 = gridPoints.get(2).y - gridPoints.get(1).y;
                float px2px3 = gridPoints.get(3).x - gridPoints.get(2).x;
                float py2py3 = gridPoints.get(3).y - gridPoints.get(2).y;
                float px3px0 = gridPoints.get(0).x - gridPoints.get(3).x;
                float py3py0 = gridPoints.get(0).y - gridPoints.get(3).y;
                
                int p1x = Math.round(
                        px0 + 
                        px0px1 * (i / 7.0f) - 
                        px3px0 * (j / 7.0f) - 
                        (px0px1 + px2px3) * (j / 7.0f) * (i / 7.0f)
                );
                int p1y = Math.round(
                        py0 + 
                        py0py1 * (i / 7.0f) - 
                        py3py0 * (j / 7.0f) - 
                        (py0py1 + py2py3) * (j / 7.0f) * (i / 7.0f)
                );
                
                int p2x = Math.round(
                        px1 - 
                        px0px1 * ((6 - i) / 7.0f) + 
                        px1px2 * (j / 7.0f) - 
                        (-px0px1 - px2px3) * (j / 7.0f) * ((6 - i) / 7.0f)
                ) - 1;
                int p2y = Math.round(
                        py1 - 
                        py0py1 * ((6 - i) / 7.0f) + 
                        py1py2 * (j / 7.0f) - 
                        (-py0py1 - py2py3) * (j / 7.0f) * ((6 - i) / 7.0f)
                );
                
                int p3x = Math.round(
                        px2 + 
                        px2px3 * ((6 - i) / 7.0f) -
                        px1px2 * ((6 - j) / 7.0f) - 
                        (px0px1 + px2px3) * ((6 - j) / 7.0f) * ((6 - i) / 7.0f)
                ) - 1;
                int p3y = Math.round(
                        py2 + 
                        py2py3 * ((6 - i) / 7.0f) - 
                        py1py2 * ((6 - j) / 7.0f) - 
                        (py0py1 + py2py3) * ((6 - j) / 7.0f) * ((6 - i) / 7.0f)
                ) - 1;
                
                
                int p4x = Math.round(
                        px3 - 
                        px2px3 * (i / 7.0f) +
                        px3px0 * ((6 - j) / 7.0f) - 
                        (-px2px3 - px0px1) * ((6 - j) / 7.0f) * (i / 7.0f)
                );
                int p4y = Math.round(
                        py3 - 
                        py2py3 * (i / 7.0f) + 
                        py3py0 * ((6 - j) / 7.0f) - 
                        (-py2py3 - py0py1) * ((6 - j) / 7.0f) * (i / 7.0f)
                ) - 1;
                
                gridSquares[c] = new GridSquare(new Point(p1x, p1y), new Point(p2x, p2y), new Point(p3x, p3y), new Point(p4x, p4y));
            }
        }
    }
    
    @Override
    public void mouseClicked(MouseEvent me) {
        if (gridPoints.size() >= 4)
            return;
        int x = me.getX() - px;
        int y = me.getY() - py;
        gridPoints.add(new Point(x, y));
        if (gridPoints.size() == 4)
            letDownTheGrid();
        System.out.println("Mouse clicked!");
    }

    @Override
    public void mousePressed(MouseEvent me) {
    }

    @Override
    public void mouseReleased(MouseEvent me) {
    }

    @Override
    public void mouseEntered(MouseEvent me) {
    }

    @Override
    public void mouseExited(MouseEvent me) {
    }

    /**
     * @return the blobs
     */
    public List<Blob> getBlobs() {
        return blobs;
    }

    /**
     * @return the trackingBlob
     */
    public Blob getTrackingBlob() {
        return trackingBlob;
    }

    /**
     * @param trackingBlob the trackingBlob to set
     */
    public void setTrackingBlob(Blob trackingBlob) {
        this.trackingBlob = trackingBlob;
    }
    
    
    /**
     * All the MovementListeners
     * @param toAdd 
     */
    public void addListener(MovementListener toAdd) {
        listeners.add(toAdd);
    }
    
    public void removeListener(MovementListener toRemove) {
        listeners.remove(toRemove);
    }

    public void executeBorderCross(Point p) {
        MovementEvent evt = new MovementEvent(p, MovementEvent.BORDER_CROSS_EVENT);
        listeners.forEach((hl) -> {
            hl.movementPerformed(evt);
        });
    }

    public void executeMovement(Point p) {
        MovementEvent evt = new MovementEvent(p, MovementEvent.MOVEMENT_EVENT);
        listeners.forEach((hl) -> {
            hl.movementPerformed(evt);
        });
    }

    public void executeMovementStemp(Point p) {
        MovementEvent evt = new MovementEvent(p, MovementEvent.MOVEMENT_STEMP_EVENT);
        listeners.forEach((hl) -> {
            hl.movementPerformed(evt);
        });
    }
}
