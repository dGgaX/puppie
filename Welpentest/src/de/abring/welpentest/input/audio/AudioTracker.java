/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.abring.welpentest.input.audio;

import java.awt.Point;
import java.io.ByteArrayOutputStream;
import static java.lang.Thread.sleep;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.TargetDataLine;

/**
 *
 * @author Karima
 */
public class AudioTracker {
    
    private final List<AudioListener> listeners = new ArrayList<>();

    private int noiceLevel = 0;
    
    public AudioTracker() {
        getNoice.start();
        audioThread.start();
        audioStempThread.start();
    }
    
    private final Thread audioThread = new Thread() {
        private long startMillis = System.currentTimeMillis();
        @Override
        public void run() {
            while(true) {
                try {
                    sleep(100);
                    int tickMillis = Math.toIntExact(System.currentTimeMillis() - startMillis);


                    Point tick = new Point(tickMillis, noiceLevel);

                    

                    executeNoice(tick);
                } catch(InterruptedException e) {
                    startMillis = System.currentTimeMillis();
                }
            }
        }
    };
    
    private final Thread audioStempThread = new Thread() {
        private long startMillis = System.currentTimeMillis();
        @Override
        public void run() {
            long roundMillis = System.currentTimeMillis();
            int count = 0;
            int noice = 0;
            while(true) {
                try {
                    sleep(5);

                    noice += noiceLevel;
                    count++;


                    if (System.currentTimeMillis() - roundMillis > 250) {
                        int avgNoice = Math.round((float)noice / (float) count);
                    
                        int tickMillis = Math.toIntExact(System.currentTimeMillis() - startMillis);

                        Point tick;
                        if (avgNoice > 400)
                            tick = new Point(tickMillis, 2);
                        else
                            tick = new Point(tickMillis, 1);

                        executeNoiceStemp(tick);
                        
                        
                        roundMillis = System.currentTimeMillis();
                        count = 0;
                        noice = 0;
                    }
                } catch(InterruptedException e) {
                    startMillis = System.currentTimeMillis();
                }
            }
        }
    };
    
    private final Thread getNoice = new Thread() {
        @Override
        public void run() {
            AudioFormat fmt = new AudioFormat(44100f, 16, 1, true, false);
            final int bufferByteSize = 2048;

            TargetDataLine line;
            try {
                line = AudioSystem.getTargetDataLine(fmt);
                line.open(fmt, bufferByteSize);
            } catch(LineUnavailableException e) {
                System.err.println(e);
                return;
            }

            byte[] buf = new byte[bufferByteSize];
            float[] samples = new float[bufferByteSize / 2];

            float lastPeak = 0f;

            line.start();
            for(int b; (b = line.read(buf, 0, buf.length)) > -1;) {

                // convert bytes to samples here
                for(int i = 0, s = 0; i < b;) {
                    int sample = 0;

                    sample |= buf[i++] & 0xFF; // (reverse these two lines
                    sample |= buf[i++] << 8;   //  if the format is big endian)

                    // normalize to range of +/-1.0f
                    samples[s++] = sample / 32768f;
                }

                float rms = 0f;
                float peak = 0f;
                for(float sample : samples) {

                    float abs = Math.abs(sample);
                    if(abs > peak) {
                        peak = abs;
                    }

                    rms += sample * sample;
                }

                rms = (float)Math.sqrt(rms / samples.length);

                if(lastPeak > peak) {
                    peak = lastPeak * 0.875f;
                }

                lastPeak = peak;

                noiceLevel = Math.round(rms * 10000);
            }
        }
    };
      
    public void resetThreads() {
        audioThread.interrupt();
        audioStempThread.interrupt();
    }
    
    public void addListener(AudioListener toAdd) {
        listeners.add(toAdd);
    }
    
    public void removeListener(AudioListener toRemove) {
        listeners.remove(toRemove);
    }

    public void executeNoice(Point p) {
        AudioEvent evt = new AudioEvent(p, AudioEvent.NOICE_EVENT);
        listeners.forEach((hl) -> {
            hl.audioDetected(evt);
        });
    }

    public void executeNoiceStemp(Point p) {
        AudioEvent evt = new AudioEvent(p, AudioEvent.NOICE_STEMP_EVENT);
        listeners.forEach((hl) -> {
            hl.audioDetected(evt);
        });
    }
}
